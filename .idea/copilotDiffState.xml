<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/sanex/cleaner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/sanex/cleaner.py" />
              <option name="originalContent" value="from .functions import (&#10;    snakecase, camelcase, pascalcase,&#10;    kebabcase, titlecase, lowercase,&#10;    screaming_snakecase, clean_column_names,&#10;    remove_duplicates, fill_missing, drop_missing,&#10;    remove_whitespace, replace_text, drop_single_value_columns,&#10;    handle_outliers, cap_outliers, remove_outliers,&#10;    standardize_booleans, remove_unwanted_rows_and_cols,&#10;    extract_and_clean_numeric, clean_numeric, extract_email,&#10;    extract_with_regex, extract_phone_numbers, remove_punctuation)&#10;import pandas as pd&#10;import polars as pl&#10;from typing import Union, List, Optional&#10;&#10;DataFrameType = Union[pd.DataFrame, pl.DataFrame]&#10;&#10;class Sanex:&#10;    def __init__(self, df):&#10;        if not isinstance(df, (pd.DataFrame, pl.DataFrame)):&#10;            raise TypeError(&quot;Input must be a pandas or polars DataFrame.&quot;)&#10;        self._df = df&#10;&#10;&#10;    def clean_column_names(self, case: str = 'snake'):&#10;                &quot;&quot;&quot;&#10;                Cleans the column names of the DataFrame.&#10;&#10;                Args:&#10;                    case (str): The desired case format for the column names.&#10;                                Defaults to 'snake'. Supported formats include:&#10;                                'snake', 'camel', 'pascal', 'kebab', 'title',&#10;                                'lower', and 'screaming_snake'.&#10;&#10;                Returns:&#10;                    Sanex: The instance of the class to allow method chaining.&#10;&#10;                This is a chainable method.&#10;                &quot;&quot;&quot;&#10;                self._df = clean_column_names(self._df, case=case)&#10;                return self&#10;&#10;    def remove_duplicates(self):&#10;        &quot;&quot;&quot;&#10;        Removes duplicate rows and columns from the DataFrame.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_duplicates(self._df)&#10;        return self&#10;&#10;    def snakecase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to snake_case.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = snakecase(self._df)&#10;        return self&#10;&#10;    def camelcase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to camelCase.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = camelcase(self._df)&#10;        return self&#10;&#10;    def pascalcase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to PascalCase.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = pascalcase(self._df)&#10;        return self&#10;&#10;    def kebabcase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to kebab-case.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = kebabcase(self._df)&#10;        return self&#10;&#10;    def titlecase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to Title Case.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = titlecase(self._df)&#10;        return self&#10;&#10;    def lowercase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to lowercase.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = lowercase(self._df)&#10;        return self&#10;&#10;    def screaming_snakecase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to SCREAMING_SNAKE_CASE.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = screaming_snakecase(self._df)&#10;        return self&#10;&#10;    def fill_missing(self, value: Union[int, float, str] = 0, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Fills missing values in the DataFrame with a specified value.&#10;&#10;        Parameters:&#10;        value (Union[int, float, str]): The value to replace missing values with. Default is 0.&#10;        subset (list): List of column names to consider for filling. Default is None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = fill_missing(self._df, value=value, subset=subset)&#10;        return self&#10;&#10;    def drop_missing(self, how: str = 'any', thresh: int = None, subset: list = None, axis: str = 'rows'):&#10;        &quot;&quot;&quot;&#10;        Drops rows or columns with missing values from the DataFrame.&#10;&#10;        Parameters:&#10;        how (str): 'any' to drop if any NA values are present, 'all' to drop if all values are NA. Default is 'any'.&#10;        thresh (int): Require that many non-NA values to avoid dropping. Default is None.&#10;        subset (list): List of column names to consider for dropping. Default is None (all columns).&#10;        axis (str): 'rows' to drop rows, 'columns' to drop columns. Default is 'rows'.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = drop_missing(self._df, how=how, thresh=thresh, subset=subset, axis=axis)&#10;        return self&#10;&#10;    def remove_whitespace(self):&#10;        &quot;&quot;&quot;&#10;        Removes leading and trailing whitespace from string entries in the DataFrame.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_whitespace(self._df)&#10;        return self&#10;&#10;    def replace_text(self, to_replace: str, value: str, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Replaces occurrences of a specified substring with another substring in the DataFrame.&#10;&#10;        Parameters:&#10;        to_replace (str): The substring to be replaced.&#10;        value (str): The substring to replace with.&#10;        subset (list): List of column names to consider for replacement. Default is None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = replace_text(self._df, to_replace=to_replace, value=value, subset=subset)&#10;        return self&#10;&#10;    def drop_single_value_columns(self):&#10;        &quot;&quot;&quot;&#10;        Drops columns that contain only a single unique value from the DataFrame.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = drop_single_value_columns(self._df)&#10;        return self&#10;&#10;    def handle_outliers(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Handles outliers in the DataFrame using the specified method.&#10;&#10;        Parameters:&#10;        method (str): The method to use for handling outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for outlier handling. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = handle_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def cap_outliers(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Caps outliers in the DataFrame using the specified method.&#10;&#10;        Parameters:&#10;        method (str): The method to use for capping outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for outlier capping. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = cap_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def remove_outliers(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Removes outliers from the DataFrame using the specified method.&#10;&#10;        Parameters:&#10;        method (str): The method to use for removing outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for outlier removal. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def standardize_booleans(self, true_values: list = None, false_values: list = None, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Standardizes boolean-like values in the DataFrame to actual boolean types.&#10;&#10;        Parameters:&#10;        true_values (list): List of values to be considered as True. Default is ['yes', 'y', 'true', 't', '1'].&#10;        false_values (list): List of values to be considered as False. Default is ['no', 'n', 'false', 'f', '0'].&#10;        subset (list): List of column names to consider for boolean standardization. Default is None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = standardize_booleans(self._df, true_values=true_values, false_values=false_values, subset=subset)&#10;        return self&#10;&#10;    def remove_unwanted_rows_and_cols(self, unwanted_values: Optional[List[Union[str, int, float]]] = None):&#10;        &quot;&quot;&quot;&#10;        Removes rows and columns that contain only unwanted values from the DataFrame.&#10;&#10;        Parameters:&#10;        unwanted_values (List[Union[str, int, float]], optional): List of values considered unwanted.&#10;            Defaults to [None, '', 'NA', 'N/A', 'null', 'NULL', 'NaN'].&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_unwanted_rows_and_cols(self._df, unwanted_values=unwanted_values)&#10;        return self&#10;&#10;    def extract_and_clean_numeric(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts and cleans numeric data from string entries in the DataFrame.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for numeric extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = extract_and_clean_numeric(self._df, subset=subset)&#10;        return self&#10;&#10;    def clean_numeric(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Cleans numeric columns in the DataFrame by extracting numeric values from strings&#10;        and handling outliers.&#10;&#10;        Parameters:&#10;        method (str): The method to use for handling outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for cleaning. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = clean_numeric(self._df, subset=subset)&#10;        self._df = handle_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def extract_email(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts email addresses from string entries in the DataFrame and places them in new columns.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for email extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = extract_email(self._df, subset=subset)&#10;        return self&#10;&#10;    def extract_with_regex(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts substrings matching a given regex pattern from specified columns in the DataFrame&#10;        and places them in new columns.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        if subset is None:&#10;            # Handle different DataFrame types correctly&#10;            if isinstance(self._df, pd.DataFrame):&#10;                subset = list(self._df.columns)  # Use list constructor instead of tolist()&#10;            else:  # polars DataFrame&#10;                subset = self._df.columns  # Already a list in polars&#10;        pattern = input(&quot;Enter the regex pattern to extract: &quot;)&#10;        self._df = extract_with_regex(self._df, pattern=pattern, subset=subset)&#10;        return self&#10;&#10;    def extract_phone_numbers(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts phone numbers from string entries in the DataFrame and places them in new columns.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for phone number extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        if subset is None:&#10;            # Handle different DataFrame types correctly&#10;            if isinstance(self._df, pd.DataFrame):&#10;                subset = list(self._df.columns)  # Use list constructor instead of tolist()&#10;            else:  # polars DataFrame&#10;                subset = self._df.columns  # Already a list in polars&#10;        self._df = extract_phone_numbers(self._df, subset=subset)&#10;        return self  # Add missing return statement&#10;&#10;    def remove_punctuation(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Removes punctuation from string entries in the DataFrame.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for punctuation removal.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_punctuation(self._df, subset=subset)&#10;        return self&#10;&#10;    def to_df(self) -&gt; DataFrameType:&#10;        &quot;&quot;&quot;&#10;        Returns the final, cleaned DataFrame.&#10;        &quot;&quot;&quot;&#10;        return self._df&#10;" />
              <option name="updatedContent" value="from .functions import (&#10;    snakecase, camelcase, pascalcase,&#10;    kebabcase, titlecase, lowercase,&#10;    screaming_snakecase, clean_column_names,&#10;    remove_duplicates, fill_missing, drop_missing,&#10;    remove_whitespace, replace_text, drop_single_value_columns,&#10;    handle_outliers, cap_outliers, remove_outliers,&#10;    standardize_booleans, remove_unwanted_rows_and_cols,&#10;    extract_and_clean_numeric, clean_numeric, extract_email,&#10;    extract_with_regex, extract_phone_numbers, remove_punctuation)&#10;import pandas as pd&#10;import polars as pl&#10;from typing import Union, List, Optional&#10;&#10;DataFrameType = Union[pd.DataFrame, pl.DataFrame]&#10;&#10;class Sanex:&#10;    def __init__(self, df):&#10;        if not isinstance(df, (pd.DataFrame, pl.DataFrame)):&#10;            raise TypeError(&quot;Input must be a pandas or polars DataFrame.&quot;)&#10;        self._df = df&#10;&#10;&#10;    def clean_column_names(self, case: str = 'snake'):&#10;                &quot;&quot;&quot;&#10;                Cleans the column names of the DataFrame.&#10;&#10;                Args:&#10;                    case (str): The desired case format for the column names.&#10;                                Defaults to 'snake'. Supported formats include:&#10;                                'snake', 'camel', 'pascal', 'kebab', 'title',&#10;                                'lower', and 'screaming_snake'.&#10;&#10;                Returns:&#10;                    Sanex: The instance of the class to allow method chaining.&#10;&#10;                This is a chainable method.&#10;                &quot;&quot;&quot;&#10;                self._df = clean_column_names(self._df, case=case)&#10;                return self&#10;&#10;    def remove_duplicates(self):&#10;        &quot;&quot;&quot;&#10;        Removes duplicate rows and columns from the DataFrame.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_duplicates(self._df)&#10;        return self&#10;&#10;    def snakecase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to snake_case.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = snakecase(self._df)&#10;        return self&#10;&#10;    def camelcase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to camelCase.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = camelcase(self._df)&#10;        return self&#10;&#10;    def pascalcase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to PascalCase.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = pascalcase(self._df)&#10;        return self&#10;&#10;    def kebabcase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to kebab-case.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = kebabcase(self._df)&#10;        return self&#10;&#10;    def titlecase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to Title Case.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = titlecase(self._df)&#10;        return self&#10;&#10;    def lowercase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to lowercase.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = lowercase(self._df)&#10;        return self&#10;&#10;    def screaming_snakecase(self):&#10;        &quot;&quot;&quot;&#10;        Converts all column names in the DataFrame to SCREAMING_SNAKE_CASE.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = screaming_snakecase(self._df)&#10;        return self&#10;&#10;    def fill_missing(self, value: Union[int, float, str] = 0, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Fills missing values in the DataFrame with a specified value.&#10;&#10;        Parameters:&#10;        value (Union[int, float, str]): The value to replace missing values with. Default is 0.&#10;        subset (list): List of column names to consider for filling. Default is None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = fill_missing(self._df, value=value, subset=subset)&#10;        return self&#10;&#10;    def drop_missing(self, how: str = 'any', thresh: int = None, subset: list = None, axis: str = 'rows'):&#10;        &quot;&quot;&quot;&#10;        Drops rows or columns with missing values from the DataFrame.&#10;&#10;        Parameters:&#10;        how (str): 'any' to drop if any NA values are present, 'all' to drop if all values are NA. Default is 'any'.&#10;        thresh (int): Require that many non-NA values to avoid dropping. Default is None.&#10;        subset (list): List of column names to consider for dropping. Default is None (all columns).&#10;        axis (str): 'rows' to drop rows, 'columns' to drop columns. Default is 'rows'.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = drop_missing(self._df, how=how, thresh=thresh, subset=subset, axis=axis)&#10;        return self&#10;&#10;    def remove_whitespace(self):&#10;        &quot;&quot;&quot;&#10;        Removes leading and trailing whitespace from string entries in the DataFrame.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_whitespace(self._df)&#10;        return self&#10;&#10;    def replace_text(self, to_replace: str, value: str, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Replaces occurrences of a specified substring with another substring in the DataFrame.&#10;&#10;        Parameters:&#10;        to_replace (str): The substring to be replaced.&#10;        value (str): The substring to replace with.&#10;        subset (list): List of column names to consider for replacement. Default is None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = replace_text(self._df, to_replace=to_replace, value=value, subset=subset)&#10;        return self&#10;&#10;    def drop_single_value_columns(self):&#10;        &quot;&quot;&quot;&#10;        Drops columns that contain only a single unique value from the DataFrame.&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = drop_single_value_columns(self._df)&#10;        return self&#10;&#10;    def handle_outliers(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Handles outliers in the DataFrame using the specified method.&#10;&#10;        Parameters:&#10;        method (str): The method to use for handling outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for outlier handling. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = handle_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def cap_outliers(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Caps outliers in the DataFrame using the specified method.&#10;&#10;        Parameters:&#10;        method (str): The method to use for capping outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for outlier capping. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = cap_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def remove_outliers(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Removes outliers from the DataFrame using the specified method.&#10;&#10;        Parameters:&#10;        method (str): The method to use for removing outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for outlier removal. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def standardize_booleans(self, true_values: list = None, false_values: list = None, columns: list = None):&#10;        &quot;&quot;&quot;&#10;        Standardizes boolean-like values in the DataFrame to actual boolean types.&#10;&#10;        Parameters:&#10;        true_values (list): List of values to be considered as True. Default is ['yes', 'y', 'true', 't', '1'].&#10;        false_values (list): List of values to be considered as False. Default is ['no', 'n', 'false', 'f', '0'].&#10;        columns (list): List of column names to consider for boolean standardization. Default is None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = standardize_booleans(self._df, true_values=true_values, false_values=false_values, columns=columns)&#10;        return self&#10;&#10;    def remove_unwanted_rows_and_cols(self, unwanted_values: Optional[List[Union[str, int, float]]] = None):&#10;        &quot;&quot;&quot;&#10;        Removes rows and columns that contain only unwanted values from the DataFrame.&#10;&#10;        Parameters:&#10;        unwanted_values (List[Union[str, int, float]], optional): List of values considered unwanted.&#10;            Defaults to [None, '', 'NA', 'N/A', 'null', 'NULL', 'NaN'].&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_unwanted_rows_and_cols(self._df, unwanted_values=unwanted_values)&#10;        return self&#10;&#10;    def extract_and_clean_numeric(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts and cleans numeric data from string entries in the DataFrame.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for numeric extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = extract_and_clean_numeric(self._df, subset=subset)&#10;        return self&#10;&#10;    def clean_numeric(self, method: str = 'iqr', factor: float = 1.5, subset: list = None):&#10;        &quot;&quot;&quot;&#10;        Cleans numeric columns in the DataFrame by extracting numeric values from strings&#10;        and handling outliers.&#10;&#10;        Parameters:&#10;        method (str): The method to use for handling outliers. Default is 'iqr'.&#10;                      Supported methods include 'iqr' (Interquartile Range) and 'zscore' (Z-Score).&#10;        factor (float): The factor to use for determining outlier thresholds. Default is 1.5.&#10;                        For 'iqr', this is the multiplier for the IQR. For 'zscore', this is the Z-Score threshold.&#10;        subset (list): List of column names to consider for cleaning. Default is None (all numeric columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = clean_numeric(self._df, subset=subset)&#10;        self._df = handle_outliers(self._df, method=method, factor=factor, subset=subset)&#10;        return self&#10;&#10;    def extract_email(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts email addresses from string entries in the DataFrame and places them in new columns.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for email extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = extract_email(self._df, subset=subset)&#10;        return self&#10;&#10;    def extract_with_regex(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts substrings matching a given regex pattern from specified columns in the DataFrame&#10;        and places them in new columns.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        if subset is None:&#10;            # Handle different DataFrame types correctly&#10;            if isinstance(self._df, pd.DataFrame):&#10;                subset = list(self._df.columns)  # Use list constructor instead of tolist()&#10;            else:  # polars DataFrame&#10;                subset = self._df.columns  # Already a list in polars&#10;        pattern = input(&quot;Enter the regex pattern to extract: &quot;)&#10;        self._df = extract_with_regex(self._df, pattern=pattern, subset=subset)&#10;        return self&#10;&#10;    def extract_phone_numbers(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Extracts phone numbers from string entries in the DataFrame and places them in new columns.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for phone number extraction.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        if subset is None:&#10;            # Handle different DataFrame types correctly&#10;            if isinstance(self._df, pd.DataFrame):&#10;                subset = list(self._df.columns)  # Use list constructor instead of tolist()&#10;            else:  # polars DataFrame&#10;                subset = self._df.columns  # Already a list in polars&#10;        self._df = extract_phone_numbers(self._df, subset=subset)&#10;        return self  # Add missing return statement&#10;&#10;    def remove_punctuation(self, subset: Optional[List[str]] = None):&#10;        &quot;&quot;&quot;&#10;        Removes punctuation from string entries in the DataFrame.&#10;&#10;        Parameters:&#10;        subset (List[str], optional): List of column names to consider for punctuation removal.&#10;            Defaults to None (all columns).&#10;&#10;        Returns:&#10;            Sanex: The instance of the class to allow method chaining.&#10;&#10;        This is a chainable method.&#10;        &quot;&quot;&quot;&#10;        self._df = remove_punctuation(self._df, subset=subset)&#10;        return self&#10;&#10;    def to_df(self) -&gt; DataFrameType:&#10;        &quot;&quot;&quot;&#10;        Returns the final, cleaned DataFrame.&#10;        &quot;&quot;&quot;&#10;        return self._df" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/sanex/functions/_standardize_booleans.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/sanex/functions/_standardize_booleans.py" />
              <option name="originalContent" value="import pandas as pd&#10;import polars as pl&#10;from typing import Union, Dict, Optional, List&#10;&#10;# Define constants for recognized boolean and missing values&#10;DataFrameType = Union[pd.DataFrame, pl.DataFrame]&#10;DEFAULT_TRUE_VALUES = {'true', '1', 't', 'yes', 'y', 'on'}&#10;DEFAULT_FALSE_VALUES = {'false', '0', 'f', 'no', 'n', 'off'}&#10;DEFAULT_MISSING_VALUES = {'', 'nan', 'null', 'none'}&#10;&#10;&#10;def standardize_booleans(&#10;    df: DataFrameType,&#10;    true_values: List[str] = None,&#10;    false_values: List[str] = None,&#10;    columns: List[str] = None&#10;) -&gt; DataFrameType:&#10;    &quot;&quot;&quot;&#10;    Standardizes boolean-like columns in the DataFrame to actual boolean types.&#10;    Recognizes various representations of true, false, and missing values.&#10;&#10;    Parameters:&#10;    df (DataFrameType): Input DataFrame.&#10;    true_values (List[str], optional): List of values to be considered as True.&#10;                                       Default is ['yes', 'y', 'true', 't', '1', 'on'].&#10;    false_values (List[str], optional): List of values to be considered as False.&#10;                                        Default is ['no', 'n', 'false', 'f', '0', 'off'].&#10;    columns (List[str], optional): List of column names to consider for boolean standardization.&#10;                                  Default is None (all columns).&#10;&#10;    Returns:&#10;    DataFrameType: DataFrame with standardized boolean columns.&#10;    &quot;&quot;&quot;&#10;    # Use default values if not provided&#10;    true_set = set(v.lower() for v in true_values) if true_values else DEFAULT_TRUE_VALUES&#10;    false_set = set(v.lower() for v in false_values) if false_values else DEFAULT_FALSE_VALUES&#10;    missing_set = DEFAULT_MISSING_VALUES&#10;    all_values = true_set | false_set | missing_set&#10;&#10;    if isinstance(df, pd.DataFrame):&#10;        # Create a mapping dictionary for efficient conversion&#10;        mapping: Dict[str, Optional[bool]] = {v: True for v in true_set}&#10;        mapping.update({v: False for v in false_set})&#10;        mapping.update({v: None for v in missing_set})&#10;&#10;        # Work on a copy to avoid modifying the original DataFrame&#10;        df_copy = df.copy()&#10;&#10;        # Determine which columns to process&#10;        columns_to_process = columns if columns else df_copy.select_dtypes(include=['object', 'string']).columns&#10;&#10;        # Iterate only over specified columns or object/string columns&#10;        for col in columns_to_process:&#10;            if col not in df_copy.columns:&#10;                continue&#10;&#10;            # Skip non-string columns if they're in the subset&#10;            if columns and df_copy[col].dtype not in ['object', 'string']:&#10;                continue&#10;&#10;            # Clean the series to check if all values are boolean-like&#10;            cleaned_series = df_copy[col].astype(str).str.lower().str.strip()&#10;&#10;            # If all values are in our defined set, perform the conversion&#10;            if cleaned_series.isin(all_values).all():&#10;                df_copy[col] = cleaned_series.map(mapping).astype('boolean')&#10;&#10;        return df_copy&#10;&#10;    elif isinstance(df, pl.DataFrame):&#10;        # Determine which columns to process&#10;        columns_to_process = columns if columns else df.columns&#10;&#10;        # Iterate through selected columns&#10;        for col in columns_to_process:&#10;            if col not in df.columns:&#10;                continue&#10;&#10;            # Skip columns that are already boolean&#10;            if df[col].dtype == pl.Boolean:&#10;                continue&#10;&#10;            # For string columns, check if they can be standardized&#10;            if df[col].dtype == pl.Utf8:&#10;                # Clean the column values&#10;                lower_col = df[col].str.to_lowercase().str.strip_chars()&#10;&#10;                # If all values are boolean-like, convert the column&#10;                if lower_col.is_in(list(all_values)).all():&#10;                    df = df.with_column(&#10;                        pl.when(lower_col.is_in(list(true_set))).then(True)&#10;                        .when(lower_col.is_in(list(false_set))).then(False)&#10;                        .otherwise(None).alias(col)&#10;                    )&#10;        return df&#10;&#10;    raise TypeError(&quot;Input must be a pandas or polars DataFrame.&quot;)&#10;" />
              <option name="updatedContent" value="import pandas as pd&#10;import polars as pl&#10;from typing import Union, Dict, Optional, List&#10;&#10;# Define constants for recognized boolean and missing values&#10;DataFrameType = Union[pd.DataFrame, pl.DataFrame]&#10;DEFAULT_TRUE_VALUES = {'true', '1', 't', 'yes', 'y', 'on'}&#10;DEFAULT_FALSE_VALUES = {'false', '0', 'f', 'no', 'n', 'off'}&#10;DEFAULT_MISSING_VALUES = {'', 'nan', 'null', 'none'}&#10;&#10;&#10;def standardize_booleans(&#10;    df: DataFrameType,&#10;    true_values: List[str] = None,&#10;    false_values: List[str] = None,&#10;    columns: List[str] = None&#10;) -&gt; DataFrameType:&#10;    &quot;&quot;&quot;&#10;    Standardizes boolean-like columns in the DataFrame to actual boolean types.&#10;    Recognizes various representations of true, false, and missing values.&#10;&#10;    Parameters:&#10;    df (DataFrameType): Input DataFrame.&#10;    true_values (List[str], optional): List of values to be considered as True.&#10;                                       Default is ['yes', 'y', 'true', 't', '1', 'on'].&#10;    false_values (List[str], optional): List of values to be considered as False.&#10;                                        Default is ['no', 'n', 'false', 'f', '0', 'off'].&#10;    columns (List[str], optional): List of column names to consider for boolean standardization.&#10;                                  Default is None (all columns).&#10;&#10;    Returns:&#10;    DataFrameType: DataFrame with standardized boolean columns.&#10;    &quot;&quot;&quot;&#10;    # Use default values if not provided&#10;    true_set = set(v.lower() for v in true_values) if true_values else DEFAULT_TRUE_VALUES&#10;    false_set = set(v.lower() for v in false_values) if false_values else DEFAULT_FALSE_VALUES&#10;    missing_set = DEFAULT_MISSING_VALUES&#10;    all_values = true_set | false_set | missing_set&#10;&#10;    if isinstance(df, pd.DataFrame):&#10;        # Create a mapping dictionary for efficient conversion&#10;        mapping: Dict[str, Optional[bool]] = {v: True for v in true_set}&#10;        mapping.update({v: False for v in false_set})&#10;        mapping.update({v: None for v in missing_set})&#10;&#10;        # Work on a copy to avoid modifying the original DataFrame&#10;        df_copy = df.copy()&#10;&#10;        # Determine which columns to process&#10;        columns_to_process = columns if columns else df_copy.select_dtypes(include=['object', 'string']).columns&#10;&#10;        # Iterate only over specified columns or object/string columns&#10;        for col in columns_to_process:&#10;            if col not in df_copy.columns:&#10;                continue&#10;&#10;            # Skip non-string columns if they're in the subset&#10;            if columns and df_copy[col].dtype not in ['object', 'string']:&#10;                continue&#10;&#10;            # Clean the series to check if all values are boolean-like&#10;            cleaned_series = df_copy[col].astype(str).str.lower().str.strip()&#10;&#10;            # If all values are in our defined set, perform the conversion&#10;            if cleaned_series.isin(all_values).all():&#10;                df_copy[col] = cleaned_series.map(mapping).astype('boolean')&#10;&#10;        return df_copy&#10;&#10;    elif isinstance(df, pl.DataFrame):&#10;        # Determine which columns to process&#10;        columns_to_process = columns if columns else df.columns&#10;&#10;        # Iterate through selected columns&#10;        for col in columns_to_process:&#10;            if col not in df.columns:&#10;                continue&#10;&#10;            # Skip columns that are already boolean&#10;            if df[col].dtype == pl.Boolean:&#10;                continue&#10;&#10;            # For string columns, check if they can be standardized&#10;            if df[col].dtype == pl.Utf8:&#10;                # Clean the column values&#10;                lower_col = df[col].str.to_lowercase().str.strip_chars()&#10;&#10;                # If all values are boolean-like, convert the column&#10;                if lower_col.is_in(list(all_values)).all():&#10;                    df = df.with_columns(&#10;                        pl.when(lower_col.is_in(list(true_set))).then(True)&#10;                        .when(lower_col.is_in(list(false_set))).then(False)&#10;                        .otherwise(None).alias(col)&#10;                    )&#10;        return df&#10;&#10;    raise TypeError(&quot;Input must be a pandas or polars DataFrame.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>